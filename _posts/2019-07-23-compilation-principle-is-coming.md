---
layout: post
title: "Compilation Principle is Coming!"
description: "My study notes."
date: 2019-07-23
tags: [CS, Compiler]
comments: true
---

出於對 COD 黑書的良好印象，本著一口吃成胖子的優良傳統，我去整了一套龍書來完成「寫一個簡單的編譯器」的暑假目標。整理筆記本身對我來說是一個輔助學習的強力動作。我把它記錄在這裡，以提醒以後的自己曾經學過的東西或犯過的錯誤。

## ITEM

+ [第一章，引論](#第一章引論)
  + [第一節，語言處理器](#第一節語言處理器)
  + [第二節，一個編譯器的結構](#第二節一個編譯器的結構)
+ [第二章，一個簡單的語法制導翻譯器](#第二章一個簡單的語法制導翻譯器)
  + [第一節，語法定義](#第一節語法定義)

## 第一章，引論

### 第一節，語言處理器

+ 語言處理系統
  + **預處理器（Preprocessor）**：合併源碼，展開宏。
  + **編譯器（Compiler）**：生成目標匯編程序。
  + **匯編器（Assembler）**：生成可重定位機器代碼。
  + **鏈接器（Linker）**：處理外部內存地址，鏈接庫文件和可重定位目標文件。
  + **加載器（Loader）**：把可執行目標文件放到內存中執行。

### 第二節，一個編譯器的結構

+ 語義等價映射
  + **分析（Analysis，或稱前端（Front end））**：創建一個由組成要素和語法結構構成的中間表示，並建立符號表。
  + **綜合（Synthesis，或稱後端（Back end））**：根據中間表示和符號表創建目標程序。

#### 詞法分析（Lexical Analysis，或稱掃描（Scanning））

+ 詞法分析器讀入源碼的字符流，將其組織為**詞素（Lexeme）**的序列。

+ 對於每個詞素，詞法分析器輸出一個**語法單元（Token）**。
  + Token 被組織為這樣的形式：\<token-name, attribute-value\>。
    + token-name 是語法分析步驟使用的抽象符號，例如表示一個變量的標識符（Identifier）的抽象符號 **id**，或者表示賦值動作的抽象符號 **=**。
    + attribute-value 是符號表中關於這個詞法單元的條目的索引，例如一個變量對應的符號表條目，或者一個常量對應的符號表條目。某些詞法單元，例如表示賦值動作的詞法單元，不需要 attribute-value。

#### 語法分析（Syntax Analysis，或稱解析（Parsing））

+ 語法分析器讀入詞法分析器生成的語法單元，創建中間表示。
  + 語法樹是一個常用的表示方法。
    + 樹中的每個內部結點表示一個運算，它們的子結點表示運算的分量。
    + 語法樹給出了詞法單元流的運算順序（或稱語法結構）。

#### 語義分析（Semantic Analysis）

+ 語義分析器使用語法樹和符號表中的信息來檢查源碼是否和語言定義的語義一致，並收集類型信息，將其存放在語法樹或符號表中。
  + 類型檢查：語義分析器需要檢查每個運算符是否具有匹配的運算分量，例如要求數組下標為整數。
  + 自動類型轉換：語義分析器進行某些受允許的類型轉換，例如將一個可以應用在兩個整數或者兩個浮點數之間的二元運算符的分量全部轉化為整數或浮點數。

#### 中間代碼生成

+ 中間代碼生成器在完成語法分析和語義分析後生成一種中間表示。
  + 這種中間表示要求易於生成和易於翻譯為目標機器語言。
    + 圖 1-7 中採用了**三地址代碼（three-address code）**作為中間表示形式。這是一種類匯編的指令，具有至多三個運算分量，並使用一些類似寄存器的臨時變量存放運算結果。

#### 代碼優化

+ 代碼優化器改進中間代碼。
  + 代碼優化器完成一些在編譯期間即可進行的計算，例如圖 1-7 中的類型轉換；優化代碼，使它們更短，資源消耗更少，例如圖 1-7 中將 t3 儲存的運算結果直接賦給 id1。

#### 代碼生成

+ 代碼生成器將中間表示映射到目標語言。
  + 如果目標語言是機器語言，代碼生成器需要為每個變量合理分配寄存器或內存位置。

![](https://nicecream.top/images/compiler010201.png)

> 圖 1-7 中的 <60> 實際上為 <**number**, 4>。

> 從語法分析樹的角度來看，圖 1-7 語法分析後得到的樹形圖其實應該為三叉樹，每個語法單元名字下移為子結點，原來所處位置的結點標號替換為類似 **Sent** 的一個非終結符號。

#### 符號表管理

+ 符號表存儲了源碼中使用的量或過程的名字和屬性，允許快速查找和存取每個名字的紀錄及紀錄中的屬性。

#### 將多個步驟組合成趟

+ 趟（Pass）是上述步驟中多個步驟的組合。當希望獲取一種特定的中間表示，或從一種特定的中間表示翻譯為機器語言，或將一個特定的前端和不同的後端結合起來時，多用趟或趟的組合，而非完整的編譯流程。

## 第二章，一個簡單的語法制導翻譯器

### 第一節，語法定義

#### 上下文無關文法（Context-free Grammar，或稱文法）

+ 文法是一種描述語法的表示方法。
+ 文法由四個元素組成：
  + 一個**終結符號**集合，有時稱為詞法單元。終結符號是文法所定義的語言的基本符號。
  + 一個**非終結符號**集合，有時稱作語法變量。每個非終結符號表示一個終結符號串的集合。
  + 一個**產生式**集合。每個產生式包括一個稱為**產生式頭**或**左部**的非終結符號，一個箭頭，一個稱為**產生式體**或**右部**的由終結符號和非終結符號組成的序列。產生式用來表示某個構造的某種書寫方式。
  + 一個**開始**符號，由一個非終結符號指定。

> 詞法分析輸出詞法單元，詞法單元的名字是一個終結符號，詞法單元的屬性值（如果有）是一個指向符號表上屬性的指針，這些屬性在語法分析中不會用到，所以在討論語法分析時把終結符號與語法單元當作同義詞。

> 一個例子，由數位和分隔它們的 +，- 符號組成的語言的文法描述：
>
> 終結符號：+, -, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0
>
> 非終結符號：list, digit
>
> 產生式：
>
> + list -> list + digit \| list - digit \| digit
> + digit -> 1 \| 2 \| 3 \| 4 \| 5 \| 6 \| 7 \| 8 \| 9 \| 0
>
> 開始符號：list

> 零個終結符號組成的串稱為空串（Empty String），記為 $\epsilon$。

#### 推導

+ 從開始符號出發，不斷將某個非終結符號替換成那個非終結符號的一個產生式的體，由此推導得到的所有終結符號串的集合稱作該文法定義的**語言（Language）**。

+ 語法分析的任務是，給定一個終結符號串，找出從文法的開始符號推導出這個串的方法。如果推導失敗，則報告串中包含的語法錯誤。

#### 語法分析樹

+ 給定一個文法，語法分析樹是具有如下性質的樹：
  + 根結點的標號為文法的開始符號。
  + 葉子結點的標號為一個終結符號或 $\epsilon$。
  + 內部結點的標號為一個非終結符號。
  + 如果非終結符號 A 是一個內部結點的標號，它的子結點標號從左至右分別為 $X_1$，⋯⋯，$X_n$，必然存在產生式 $A\rightarrow X_1,...,X_n$。
+ 給定語法分析樹，其葉子結點從左至右組成的符號串稱為樹的**結果（Yield）**，也就是從這棵樹根節點的非終結符號推導得到的符號串。
+ 語法分析是這樣的過程，給定一個終結符號串，為它構建一棵語法分析樹。

#### 二義性（Ambiguous）

+ 一個文法可能有多棵語法分析樹可以生成一個給定的符號終結符號串，這樣的文法稱為具有二義性。

#### 運算符的結合性

+ 當一個運算分量的兩側有同一個運算符時，我們需要決定它屬於哪一個運算符。當它屬於左側的運算符，它被稱作左**結合（Associate）**的，否則被稱作右結合的。

> 通過為不同層次的運算結果創建非終結符號來構造不同形狀的產生式，我們可以描述運算符的結合性。

> 例子：連續賦值 a = b = c。
>
> right -> letter = right \| letter

#### 運算符的優先級

+ 當一個運算分量的兩側有不同的運算符時，我們需要決定它屬於哪一個運算符。當其中一個運算符先於另一個運算符獲得運算分量，我們說前者比後者具有更高的優先級。

> 通過為不同的優先級創建非終結符號來表示更高優先級的運算結果經由那一優先級的運算得到的運算結果，我們可以構造出具有優先級的算術表達式文法。表示這樣的運算結果的非終結符號保證了這樣的性質，在它的兩側放置低優先級的運算符，不會導致它代表的表達式被分開。

> 例子：加減乘除。
>
> expr -> expr + term \| expr - term \| term
>
> term -> term * factor \| term / factor \| factor
>
> factor -> digit \| (expr)